/*
 * Chrome Extension: Persistent Selected Text Overlay Example
 *
 * This extension allows the user to select text on a webpage and
 * displays that selected text in a persistent, dismissible overlay
 * on the top-right corner of the webpage.
 *
 * This replaces the transient popup behavior.
 *
 * File Structure:
 * persistent-text-overlay/
 * ├── manifest.json
 * ├── background.js   (Handles icon clicks and injects content script)
 * ├── content.js      (Injected into webpage, creates and manages the overlay)
 * └── images/
 * ├── icon-16.png
 * ├── icon-48.png
 * └── icon-128.png
 *
 * To run this extension:
 * 1. Create a folder named `persistent-text-overlay`.
 * 2. Save the content of `manifest.json`, `background.js`, and `content.js`
 * into files with those exact names within the `persistent-text-overlay` folder.
 * 3. Create an `images` subfolder inside `persistent-text-overlay`.
 * 4. Place placeholder icon images (PNG format) named `icon-16.png`, `icon-48.png`,
 * and `icon-128.png` in the `images` folder. You can use simple colored squares.
 * (e.g., https://placehold.co/128x128/673AB7/ffffff?text=OVR for 128x128)
 * 5. Open Chrome and go to `chrome://extensions`.
 * 6. Enable "Developer mode" (top right corner).
 * 7. Click "Load unpacked" and select your `persistent-text-overlay` folder.
 *
 * How to use after loading:
 * 1. Go to any webpage with text.
 * 2. Select some text using your mouse.
 * 3. Click the extension's icon in the Chrome toolbar.
 * 4. A floating overlay will appear on the top-right of the page with the selected text.
 * 5. This overlay will persist until you click the 'X' button or refresh the page.
 * 6. Select new text and click the icon again to update the overlay.
 */

// --- 1. manifest.json ---
// This file describes your extension.
// IMPORTANT: We remove `default_popup` and use `background.service_worker`.
// Save this as `manifest.json` in the root of your extension folder.
/*
{
  "manifest_version": 3,
  "name": "Persistent Text Overlay",
  "version": "1.0",
  "description": "Displays selected text in a persistent overlay on the page.",
  "icons": {
    "16": "images/icon-16.png",
    "48": "images/icon-48.png",
    "128": "images/icon-128.png"
  },
  "action": {
    "default_icon": {
      "16": "images/icon-16.png",
      "24": "images/icon-24.png",
      "32": "images/icon-32.png"
    }
    // No "default_popup" here, as we are injecting UI via content script
  },
  "background": {
    "service_worker": "background.js" // This script runs when the icon is clicked
  },
  "permissions": [
    "activeTab",  // Allows temporary access to the currently active tab when invoked
    "scripting"   // Required to programmatically inject content scripts
  ],
  "host_permissions": [
    "<all_urls>" // Necessary if content.js needs to run on all pages
                  // If you only need it on specific domains, list them here instead of <all_urls>
  ]
}
*/

// --- 2. background.js ---
// This is the service worker script. It listens for when the extension icon
// is clicked, then injects the content script into the active tab.
// Save this as `background.js` in the root of your extension folder.
/*
// Listen for clicks on the extension's toolbar icon
chrome.action.onClicked.addListener((tab) => {
    console.log('Extension icon clicked on tab:', tab.url);

    // Get the current selected text from the active tab.
    // We execute a function directly in the content script context to get the selection.
    chrome.scripting.executeScript(
        {
            target: { tabId: tab.id },
            function: getSelectedTextAndInjectOverlay // Function to execute in content script context
        },
        (injectionResults) => {
            if (chrome.runtime.lastError) {
                console.error('Script injection failed:', chrome.runtime.lastError.message);
                return;
            }
            if (injectionResults && injectionResults[0] && injectionResults[0].result) {
                const selectedText = injectionResults[0].result;
                console.log('Selected text retrieved:', selectedText);
                // The content script (getSelectedTextAndInjectOverlay) itself handles
                // creating/updating the overlay. No further message passing is needed here.
            } else {
                 console.warn('No text selected or script did not return a result.');
            }
        }
    );
});

// This function will be executed in the context of the webpage (content script's isolated world).
// It gets the selected text and then calls the function to manage the overlay.
// It must be defined outside the listener for `executeScript` to inject it.
function getSelectedTextAndInjectOverlay() {
    // This part runs in the context of the webpage.
    const selectedText = window.getSelection().toString();

    // Define the ID for our overlay element to easily find/remove it
    const OVERLAY_ID = 'extension-selected-text-overlay';

    // Check if the overlay already exists
    let overlay = document.getElementById(OVERLAY_ID);

    if (!overlay) {
        // If it doesn't exist, create it
        overlay = document.createElement('div');
        overlay.id = OVERLAY_ID;
        overlay.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-width: 90vw; /* Responsive width */
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            z-index: 2147483647; /* High z-index to ensure it's on top */
            font-family: 'Inter', sans-serif;
            color: #333;
            animation: fadeIn 0.3s ease-out forwards;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box; /* Include padding in width */
        `;

        // Add a style block for animations if not already present
        if (!document.getElementById('extension-overlay-styles')) {
            const style = document.createElement('style');
            style.id = 'extension-overlay-styles';
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(-20px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                @keyframes fadeOut {
                    from { opacity: 1; transform: translateY(0); }
                    to { opacity: 0; transform: translateY(-20px); }
                }
            `;
            document.head.appendChild(style);
        }

        // Add header
        const header = document.createElement('h3');
        header.textContent = 'Selected Text:';
        header.style.cssText = `
            margin: 0;
            color: #4a5568;
            font-size: 1.1em;
            text-align: left;
            padding-right: 30px; /* Space for close button */
        `;
        overlay.appendChild(header);

        // Add close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'X';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: #888;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, color 0.2s ease;
        `;
        closeButton.onmouseover = () => {
             closeButton.style.backgroundColor = '#f0f0f0';
             closeButton.style.color = '#333';
        };
        closeButton.onmouseout = () => {
             closeButton.style.backgroundColor = 'none';
             closeButton.style.color = '#888';
        };
        closeButton.onclick = () => {
            overlay.style.animation = 'fadeOut 0.3s ease-out forwards';
            overlay.addEventListener('animationend', () => overlay.remove(), { once: true });
        };
        overlay.appendChild(closeButton);

        // Add text content area
        const contentArea = document.createElement('div');
        contentArea.id = OVERLAY_ID + '-content';
        contentArea.style.cssText = `
            background-color: #f8f8f8;
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 8px;
            min-height: 50px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.4;
            color: #555;
            flex-grow: 1; /* Allow content area to grow */
        `;
        overlay.appendChild(contentArea);

        document.body.appendChild(overlay);
    } else {
        // If the overlay already exists, reset its animation and ensure visibility
        overlay.style.animation = 'none'; // Reset any previous animation state
        overlay.offsetHeight; // Trigger reflow to apply reset
        overlay.style.animation = 'fadeIn 0.3s ease-out forwards'; // Re-apply fadeIn

        // Re-append to ensure it's on top of any new content
        // (though z-index usually handles this, re-appending ensures DOM order is latest)
        document.body.appendChild(overlay);
    }

    // Update the text content
    const contentArea = document.getElementById(OVERLAY_ID + '-content');
    if (selectedText.trim() !== '') {
        contentArea.textContent = selectedText;
        contentArea.style.color = '#555';
    } else {
        contentArea.textContent = 'No text was selected. Select text and click the icon again.';
        contentArea.style.color = '#dc3545'; // Red for warning
    }

    // Return the selected text to the background script (optional, for logging)
    return selectedText;
}
*/

// --- 3. content.js (Empty/Not used directly as separate file for this approach) ---
// In this specific implementation, the JavaScript logic that runs in the page's
// context is embedded directly in the `background.js` file within the
// `getSelectedTextAndInjectOverlay` function, which is then `executeScript`-ed.
// This means you technically don't need a separate `content.js` file for this approach,
// but it's good to keep the structure in mind for more complex content script needs.
// For clarity, I'm keeping this comment block, but you don't need to create a `content.js` file
// with content if you use the `function` property of `executeScript`.
// If you wanted a larger, more complex content script, you would use `files: ['content.js']`
// in executeScript and define the entire overlay logic within `content.js` itself.
/*
// This file would contain the JavaScript for interacting with the webpage.
// For this example, its content is now part of the function injected from background.js.
*/

// --- 4. images/ (folder) ---
// Create a subfolder named `images` in your extension's root directory.
// Place three small square PNG image files inside it, named:
// - icon-16.png (e.g., 16x16 pixels)
// - icon-48.png (e.g., 48x48 pixels)
// - icon-128.png (e.g., 128x128 pixels)
// You can use any simple image, or even create blank colored squares for testing.
// For example, you can use online tools or image editors to create these.
// Example for icon-128.png: https://placehold.co/128x128/673AB7/ffffff?text=OVR
// Example for icon-48.png: https://placehold.co/48x48/673AB7/ffffff?text=OVR
// Example for icon-16.png: https://placehold.co/16x16/673AB7/ffffff?text=OVR
